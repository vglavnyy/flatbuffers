#ifndef FLATBUFFERS_MONSTERTEST_MYGAME_EXAMPLE_NATIVE_H_
#define FLATBUFFERS_MONSTERTEST_MYGAME_EXAMPLE_NATIVE_H_
// The Monster has vector of `native_type` structs (MagicPotion).
// The user must provide the Pack/UnPack functions (for details, see
// CppUsage.md):
//      namespace flatbuffers {
//        FlatbufferStruct Pack(const native_type& obj);
//        native_type UnPack(const FlatbufferStruct& obj);
//      }
// It is expected that both functions declared in the 'flatbuffers' namespace.
//
// The attribute `native_include` can be used to add this header to a generated
// code. If `native_include` is not used, the program should include this header
// in the .cpp module. The `flatc --cpp-include` can be used as well to add this
// header.

#include <complex>
#include <utility>
// Implementation of native_type API requires two stages:
// 1. Forward declaration of Pack/UnPack interface (before complete type is
// defined).
// 2. Implementation of Pack/UnPack interface when all types are known.

// Forward declaration of Pack/UnPack interface.
// Forward declaration of struct generated by schema compiler.
namespace MyGame {
struct PolarPoint;
struct Transformation;
}

// Pack/UnPack must be declared in the 'flatbuffers' namespace.
namespace flatbuffers {
MyGame::PolarPoint Pack(const std::complex<double> &z);
std::complex<double> UnPack(const MyGame::PolarPoint &p);

MyGame::Transformation Pack(const std::pair<double, double>& t);
std::pair<double, double> UnPack(const MyGame::Transformation& t);
}  // namespace flatbuffers

#endif  // FLATBUFFERS_MONSTERTEST_MYGAME_EXAMPLE_NATIVE_H_
